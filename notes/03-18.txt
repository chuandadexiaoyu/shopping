Saturday, 23 March 2013 ---------------------------------

Let's keep running notes, examples, and links with the project itself, rather than scattered all over the place.


Environment ------------------------------------------

Software technologies used:
WAMP/LAMP
SublimeText2
git
php
phpunit
Laravel 4beta
REST interface
JSON
HTML5
CSS
jQuery
(client framework?)

---
SublimeText2 Shortcuts:
    Ctrl+Shift+Backspace  Delete to beginning of line
    Ctrl+Backspace        Delete current word 
    Ctrl+L                Select current line (multiple times for multiple lines)
    Ctrl+D                Select current word/next instances (sets up multiple cursors)
    Alt+F3                Select all similar instances in document (multiple cursors)
    Ctrl+Shift+P          Command Palette
    Ctrl+P                Go to anything  (just type in the identifier); Files/folders
    Ctrl+P, @             Go to method (function)
    Ctrl+R                (does exactly the same thing as Ctrl+P,@)
    Ctrl+P, :<#>          Go to line number in file
    Ctrl+Alt+N            New file/folder (with AdvancedNewFile)
    Ctrl+K, Ctrl+B        Show/Hide sidebar
    Ctrl+Shift+D          Duplicate (selected text or line)
    Ctrl+F                Find
    Ctrl+I                Find next occurrence of a given word/string
    Ctrl+F, Alt+R         toggle regular expression searching 
    Ctrl+J                join lines
    Ctrl+E                Expand (Emmet string)
    Ctrl+Tab              switch back and forth between last used windows

Multiple panes:
    Alt+Shift+1           show all windows in 1 pane
    Alt+Shift+2           2 panes
    Alt+Shift+5           grid (2 above, 2 below)
    Ctrl+Shift+2          move current file to pane 2
    Ctrl+1                move cursor to pane 1
    

SublimeText2 Installed Packages
    AdvancedNewFile             Type in new path/file to create and open instantly
    DocBlockr                   Create template for doc block from function/class definition 
    Emmet                       Quickly write html code, based on css descriptors. Love it!
    FindKeyConflicts            Find conflicts for quick keys
    Package Control             Easily find and install packages
    SideBarEnhancements         Full commands when right-clicking on sidebar
    SublimeLinter               Highlight lines with errors in the code after saving;
    SublimeTODO                 Create an index for all of your TODO, FIXME, and similar comments


---
git:

Basic Usage
To create a new local repository:
    git init      // Initialize a new git repository
    git remote add origin https://github.com/jijoel/project.git

To copy a remote repository to the local machine:
    git clone https://github.com/jijoel/project.git local_project_dir

To use git to send files to a remote repository:
    git add *     // Add all files in the path on the local machine to the track list
    git commit    // Commits changes to the local repository
    git push      // Pushes changes to the remote repository
	
To pull working files from the repository (eg, to get updates from other people or other places that have been pushed to the remote repository)
    git pull      // Pull (and merge) changes from the remote repository
or
    git fetch
    git merge

To see what has changed in the working tree
    git status


Advanced Usage
Pull data from a remote repository, wiping out any local changes:
    git reset --hard HEAD
    git pull

If you have local commits that you'd also like to wipe out:
    git reset --hard origin/master
    git pull
    
Configuration:
Use the nano editor for commits
    git config --global core.editor "nano"
    
Syntax highlighting in nano
http://milianw.de/code-snippets/git-commit-message-highlighting-in-nano


---
Composer:

Use composer to install additional components for the app.

Get composer at http://getcomposer.org/
It looks for a file called composer.json in your project root directory:
{
        "require": {
                "laravel/framework": "4.0.*",
                "mockery/mockery": "dev-master"
        },
        "autoload": {
                "classmap": [
                        "app/commands",
                        "app/controllers",
                        "app/models",
                        "app/database/migrations",
                        "app/database/seeds",
                        "app/tests"
                ]
        },
        "minimum-stability": "dev"
}

composer install                  // installs packages
composer update                   // updates packages
composer update --dev             // updates packages for the require-dev section
composer dump-autoload            // dumps, and refreshes the autoload list

The app will automatically load files from the autoloaded directories.
You can see what classes it found by checking:
    vendor/composer/autoload_classmap.php




MVC -----------------------------------------------------------------------------

MVC is a software pattern that separates the representation of information
from the user's interactions with it.

Model       - Classes which contain all of the business logic of the application
View        - Classes which format and present data to the user
Controller  - Classes which coordinate user actions and routing





REST  ----------------------------------------------------------------------

REST is a web service design model meant to make applications usable, well-designed, 
and easy to integrate. It does things like standardizing the naming conventions of 
components. Its goals include things like:
* Scalability of component interactions
* Generality of interfaces
* Independent deployment of components
* Intermediary components to reduce latency, enforce security and encapsulate legacy systems
* Self-similarity, and easy to learn

Per object, we only need 2 base URLs:
    plural (collection)   /dogs
    singular              /dogs/bo  (or /dogs/1)

    Resource    GET         PUT          POST               DELETE
    /dogs       list dogs   <error>      create a new dog   delete all dogs
    /dogs/bo    show bo     update bo    <error>            delete this dog (bo)

Verbs in URL are bad
Nouns are good; use plural nouns for url names
WHERE statements would be behind the question mark:
    /dogs?color=red&state=running&loc=park
    (as opposed to getRedDogsRunningAtPark)

So, where a legacy system might have functions like this:
    getUsers()
    getNewUsersSince(date SinceDate)
    savePurchaseOrder(string CustomerID, string PurchaseOrderID)

A RESTful system might have:
    /users
    /users?date>=sinceDate
    /purchaseOrder  (with POST values for the data)

Pagination:
    /users?start=x&count=y  (or offset/limit, or page/rpp)

Specific fields only:
    /users?:(id,name,etc)
or
    /users?fields=id,name,color,picture

Orders/commands/events:
    PUT /dogs/bo?command=bark
    GET /dogs/bo?:(state)
    return  {"state": "barking"}

Types:
    /users.json  (returns it as json)
    /users.xml   (returns it as xml)
    GET /dogs/bo.json?:(state)

It's better to use the Accept and Content-Type headers on the client.
    A mobile request wanting JSON back would look like:
        Accept: text/json GET /eshop/sales/topItems/monday
    A web browser request which wants pdf would send
        Accept: application/pdf GET /eshop/sales/topItems/monday
    
Inheritance:
    GET /dogs/bo
    GET /animals/bo
    (return the same result)

Laravel function mapping to REST:
    Function    REST
    index       GET - list all items
    create      GET - show form for creating new item
    store       POST - write a new item
    show        GET - Show form to display one item (eg site/photos/1)
    edit        GET - Show form for editing one item (eg site/photos/1/edit)
    update      PUT - write changes to existing item
    destroy     DESTROY - delete an item

Useful response codes for RESTful apps:
200 OK                 - This should be used only for success and nothing else. Period.
201 Created            - This should be used as a response to a POST request when a 
                         resource is created. The location header should contain 
                         the URI to the newly created resource
202 Accepted           - This can be used for async processing, 
                         with a link to the status/next step being sent by the server.
400 Bad Request        - This can be used for input validation errors.
401 Unauthorized       - User with given credentials not allowed to do requested task
403 Forbidden          - Return this in case of an authentication error 
                         instead of returning a 200
404 Not Found          - Resource was not found
405 Method Not Allowed - If there is a read only resource and a client makes 
                         a non GET request, this should be the status code 
                         returned by the server with the valid methods included 
                         as part of the Allow header
412 Precondition       - This can be used to indicate that a logical precondition 
                         check has failed
500 Internal Server Error

Others:
304 Not Modified
409 Conflict
410 Gone


Here's an idea about best-practice error handling, from
http://www.stormpath.com/blog/spring-mvc-rest-exception-handling-best-practices-part-1

  {
      "status": 404,
      "code": 40483,
      "message": "Oops! It looks like that file does not exist.",
      "developerMessage": "File resource for path /uploads/foobar.txt does not exist. 
          Please wait 10 minutes until the upload batch completes before checking again.",
      "moreInfo": "<link rel="moreinfo" href='http://www.mycompany.com/errors/40483' />"
  }

Note, on the moreinfo entry, instead of trying to construct a uri, the client can look at the respose; if the tag is there, it can use the reference directly.

    <link rel="moreInfo" href="/estore/catalog/books/id/12345"/>
    <link rel="reviews" href="http:/reviewStore/estore/reviews/id/9912345&customer=888"/>
    <link rel="rating" href="/estore/books/id/12345/rating?customer=888"/>

http://satishgopal.wordpress.com/2012/03/26/building-restful-services-part-2/
In an order, we might get this:
<order>
    <cart>
        <items>
            <item code="abc" qty="1">
            <item code="def" qty="1">
        </items>
        <link rel="update" href="/estore/order/178567/cart"/>
    </cart>
    <link rel="saveForLater" href="/estore/customer/1356/archive/order/178567"/>
    <link rel="cancel" href="/estore/order/178567"/>
    <link rel="address" href="/estore/order/178567/address"
        type="application/vnd.estore_address+xml"/>
</order>

The important point here is that the client doesn’t have to figure out from an external document as to what are the possible next states for the order. The possible next states are all captured with hyperlinks. Again, this makes for really loose coupling and provides the service a lot of flexibility in evolving business rules around order processing without breaking existing clients.

The set of possible next steps are provided by the service at any given point using hyperlinks. This is HATEOAS (Hypermedia As The Engine Of Application State) 

Test Driven Development (TDD) ---------------------------------------------------

This is a development technique that helps create more reliable code over time.
Begin by writing a test that will fail
Test it (make sure it fails)
Write the code to make the test pass
Test it (make sure it passes)
Refactor (make sure all tests still pass)

---
Mocks:
A mock is a replacement for an object that we can use for testing.
Rather than hitting an actual class (eg, to write to the database), go to a mock
Integration testing should hit actual classes

Mockery is a project that makes creation and handling of mocks easier:
in composer.json, require  "mockery/mockery": "dev-master"

Using Mocks:
(instructions from https://tutsplus.com/tutorial/better-testing-in-laravel/)
My controller is ItemsController
My model is Item

I'll set up several different classes:
ItemsController
Item
ItemRepositoryInterface
EloquentItemRepository

In ItemsController, use this:
    public function __construct(ItemRepositoryInterface $items)
    {
        $this->items = $items;
    }

    Interface ItemRepositoryInterface
    {
        public function all();
        public function find($id);
        ...
        any other functions you want the controller to be able to access
    }

    class EloquentItemRepository implements ItemRepositoryInterface
    {
        public function all(){     return Item::all(); }
        public function find($id){ return Item::find($id); }
        ... 
        other functions, just call the corresponding item function
    }

The application also needs to know the default repository to use to implement the interface:
    App::bind('ItemRepositoryInterface', 'EloquentItemRepository');

When testing, using Mockery,
    public function testMockShow()
    {
        $mock = \Mockery::mock('ItemRepositoryInterface');
        $mock->shouldReceive('find')->once()->andReturn('{"name":"works"}');
        App::instance('ItemRepositoryInterface', $mock);

        $response = $this->call('GET', 'items/1');
        $this->assertTrue($response->isOk());
        $this->assertNotEmpty($response->getContent());
        $json = json_decode($response->getContent());
        $this->assertEquals('works', $json->name);
    }

This should bypass the database completely.
In some cases, we need to return an intermediate object (eg, items/1/vendors)

    public function testShowItemVendors()
    {
        $mockVendor = $this->mock('Vendor');
        $mockVendor->shouldReceive('get')->once()->andReturn('{"name":"vendor works"}');

        $mockItem = $this->mock('Item');
        $mockItem->shouldReceive('find')->once()->andReturn($mockItem);
        $mockItem->shouldReceive('vendors')->once()->andReturn($mockVendor); 

        $response = $this->call('GET', 'items/1/vendors');
        $this->assertTrue($response->isOk());
        $this->assertNotEmpty($response->getContent());
        $json = json_decode($response->getContent());
        $this->assertEquals('vendor works', $json->name);
    }

    public function mock($class)
    {
        $repo = $class . 'RepositoryInterface';
        $mock = \Mockery::mock($repo);
        App::instance($repo, $mock);       
        return $mock;
    }

---
phpunit

I'm using phpunit for testing. It will read configuration information from phpunit.xml, in the root directory of the project.

We can only test some groups at a time:

    /**
     * @group database
     * @group remoteTasks
     */
    public function testSomething()
    {
    }

testSomething() is now in two groups, and if either is added on the command line (or in the config.xml) --exclude-group parameter. it won't be run.

phpunit --exclude-group integration         // won't run integration tests tagged with @group integration
phpunit --group integration                 // will run only tests tagged with @group integration

Tags for phpunit can be put on either classes or individual functions.


---
Make a test dependent on success of a previous test:
 
    public function testEmpty()
    {
        $stack = array();
        $this->assertTrue(empty($stack));
        return $stack;   // also sends this variable to any following tests - if this worked
    }

    /**
     * only runs if testEmpty() passed
     *
     * @depends testEmpty
     */
    public function testPush(array $stack)
    {
    }


---
Call/Response:

When unit testing, we can call functions and get the responses. We can also do this with mocks. The basic format is like this:

    $response = $this->call('GET', 'items/1/vendors');
    $this->assertTrue($response->isOk());
    $this->assertNotEmpty($response->getContent());

The response class has several useful functions, including:
    getStatusCode()
    getContent()
    getOriginalContent()

Response Helper Functions
    Function Name           Status Codes
    isInvalid()             <100 and >=600
    isInformational()       >=100 and <200
    isSuccessful()          >=200 and <300
    isRedirection()         >=300 and <400
    isClientError()         >=400 and <500
    isServerError()         >=500 and <600
    isOk()                  200
    isForbidden()           403
    isNotFound()            404
    isRedirect()            201,301,302,303,307,308
    isEmpty()               201,204,304
    isNotModified()
 
use like:
    if ($response->isOK)  doSomething;


---
Laravel 4 IoC and Facades
http://www.thenerdary.net/post/30859565484/laravel-4

When using a laravel class, we generally use a facade:
    $var = Session::get('foo');
 
Under the hood, it does this:
    $app->resolve('session')->get('foo');
 
So, we can swap out parts of the framework, like so:
    $app['session'] = function()
    {
        return new MyCustomSessionLayer;
    }
 
For instance, maybe you want to make the whole Redirect layer for a test. In your test you could just do:
    $app['redirect'] = $mock;

https://news.ycombinator.com/item?id=5044336
However, things like the Input, URL, File, etc. classes still being static could lead to some testability problems. I've broken encapsulation on the Input class just to make it a little more testable. You can set the Input just by saying "Input::$input = array()".

You can swap out entire components with your own. For instance, if you had a class that inherited from the root Response object (Illuminate\Http\Response), you could use it (instead of the standard response class) for all response handling. Just edit app/config/app.php:
    //'Response'        => 'Illuminate\Support\Facades\Response',
    'Response'        => 'Api\Facades\Response',    (your own response facade)

    
    
---
In-memory database and test environment

An in-memory database is much faster than writing data to your actual database (it doesn't require any disk reads, indexes, etc.)

From: http://net.tutsplus.com/tutorials/php/testing-like-a-boss-in-laravel-models/
Within the app/config/testing directory, create a new file, named database.php, and fill it with the following content:

    // app/config/testing/database.php
    <?php     
    return array( 
        'default' => 'sqlite',
        'connections' => array(
            'sqlite' => array(
                'driver'   => 'sqlite',
                'database' => ':memory:',
                'prefix'   => ''
            ),
        )
    );
 
Before running tests
Since the in-memory database is always empty when a connection is made, it’s important to migrate the database before every test. To do this, open app/tests/TestCase.php and add the following method to the end of the class:

    /**
     * Migrates the database.
     * This will cause the tests to run quickly.
     *
     */
    private function prepareForTests()
    {
        Artisan::call('migrate');   // sets up all tables
        $this->seed;                // seed test database values
        Mail::pretend(true);        // if using mail
    }

    // When using Mockery, it's important to close it at the end of the test
    public function tearDown()
    {
        \Mockery::close();
    }

---
Web Crawler
The Symphony web crawler component will go through the DOM of the page to handle very specific test cases. It can be used during integration tests to simulate a browser (much faster than Selenium).

// Click a link:
    $crawler = $this->client->request('GET', '/user/login');
    $link = $crawler->filter('a:contains("Greet")')->eq(1)->link();
    $crawler = $client->click($link);
 
// Find the submit button on a form:
    $form = $crawler->selectButton('submit')->form();
 
// set some values
    $form['name'] = 'Lucas';
    $form['form_name[subject]'] = 'Hey there!';
 
// submit the form
    $crawler = $client->submit($form);
  
// Assert that the response matches a given CSS selector.
    $this->assertGreaterThan(0, $crawler->filter('h1')->count());
 
Test against the Response content directly if you just want to assert that the content contains some text, or if the Response is not an XML/HTML document:
    $this->assertRegExp(
        '/Hello Fabien/',
        $client->getResponse()->getContent()
    );
 
Force each request to be executed in its own PHP process to avoid any side-effects when working with several clients in the same script:
    $client->insulate();
 
// Search through all content on page for a string
    $crawler = $this->client->request('GET', '/user/login');
    $this->assertTrue($this->client->getResponse()->isOk(), 'should have an OK response');
    $this->assertContains('Please Log In', 
        $this->client->getResponse()->getContent(), 'should contain "Please Log In" ');
 
// Find a specific string in a specific location
    $crawler = $this->client->request('GET', '/user/login');
    $this->assertCount(1, $crawler->filter('h1:contains("Please Log In")'), 
        'should contain "Please Log In" in h1 tag (only once)');
 
Useful Assertions
    // Assert that there is at least one h2 tag with the class "subtitle"
    $this->assertGreaterThan( 0, $crawler->filter('h2.subtitle')->count());
 
    // Assert that there are exactly 4 h2 tags on the page
    $this->assertCount(4, $crawler->filter('h2'));
 
    // Assert that the "Content-Type" header is "application/json"
    $this->assertTrue(
        $client->getResponse()->headers->contains(
            'Content-Type',
            'application/json'
        )
    );
 
    // Assert that the response content matches a regexp.
    $this->assertRegExp('/foo/', $client->getResponse()->getContent());
 
    // Assert that the response status code is 2xx
    $this->assertTrue($client->getResponse()->isSuccessful());
 
    // Assert that the response status code is 404
    $this->assertTrue($client->getResponse()->isNotFound());
 
    // Assert a specific 200 status code
    $this->assertEquals(200,$client->getResponse()->getStatusCode());
 
    // Assert that the response is a redirect to /demo/contact
    $this->assertTrue($client->getResponse()->isRedirect('/demo/contact'));
 
    // or simply check that the response is a redirect to any URL
    $this->assertTrue($client->getResponse()->isRedirect());
 
Browsing
The Client supports many operations that can be done in a real browser:
    $client->back();
    $client->forward();
    $client->reload();
 
    // Clears all cookies and the history
    $client->restart();
 
Accessing Internal Objects
If you use the client to test your application, you might want to access the client's internal objects:
    $history   = $client->getHistory();
    $cookieJar = $client->getCookieJar();
 
You can also get the objects related to the latest request:
    $request  = $client->getRequest();
    $response = $client->getResponse();
    $crawler  = $client->getCrawler();
 
If your requests are not insulated, you can also access the Container and the Kernel:
    $container = $client->getContainer();
    $kernel    = $client->getKernel();
 
Redirecting
When a request returns a redirect response, the client does not follow it automatically. You can examine the response and force a redirection afterwards with the followRedirect() method:
    $crawler = $client->followRedirect();
 
If you want the client to automatically follow all redirects, you can force him with the followRedirects() method:
    $client->followRedirects();
 
The Crawler
A Crawler instance is returned each time you make a request with the Client. It allows you to traverse HTML documents, select nodes, find links and forms.
 
Traversing
Like jQuery, the Crawler has methods to traverse the DOM of an HTML/XML document. For example, the following finds all input[type=submit] elements, selects the last one on the page, and then selects its immediate parent element:
    $newCrawler = $crawler->filter('input[type=submit]')
        ->last()
        ->parents()
        ->first();
 
Many other methods are also available:
    Method                  Description
    filter('h1.title')      Nodes that match the CSS selector
    filterXpath('h1')       Nodes that match the XPath expression
    eq(1)                   Node for the specified index
    first()                 First node
    last()                  Last node
    siblings()              Siblings
    nextAll()               All following siblings
    previousAll()           All preceding siblings
    parents()               Returns the parent nodes
    children()              Returns children nodes
    reduce($lambda)         Nodes for which the callable does not return false
 
Extracting Information
    // Returns the attribute value for the first node
    $crawler->attr('class');
 
    // Returns the node value for the first node
    $crawler->text();
 
    // Extracts an array of attributes for all nodes (_text returns the node value)
    // returns an array for each element in crawler, each with the value and href
    $info = $crawler->extract(array('_text', 'href'));
 
    // Executes a lambda for each node and return an array of results
    $data = $crawler->each(function ($node, $i)
    {
        return $node->attr('href');
    });
 
Links¶
To select links, you can use the traversing methods above or the convenient selectLink() shortcut:
    $crawler->selectLink('Click here');
 
    $link = $crawler->selectLink('Click here')->link();
    $client->click($link);
 
Forms
    $buttonCrawlerNode = $crawler->selectButton('submit'); 






Laravel -------------------------------------------------------------------------

Using Laravel 4:  http://four.laravel.com

---
Set Up:
To set up laravel, copy the basic project from above, and run composer install to get all of the dependencies.

Set the project root directory in apache to the /public folder
(this is a place for css, img, js, etc. files, also)

make storage directory writable:
    chmod -R o+w storage
    (or chown www-data storage/*)

application key:
    app/config/app.php
use command line to generate secure application key:
    php artisan key:generate

Laravel configuration information stored in project/app/config
Each file here returns an array with configuration information (closures are OK)
Access it at any time with Config::get. Use the file name and array key:
    Config::get('app.timezone')

For any classes that use facades (most of Laravel's classes), get the original class name with:
    echo get_class(App::getFacadeRoot());       (App, or any other class)


Laravel’s components are instances that exist within the Laravel 4 $app container object. They can be called in each of these ways:
 
    $app['component']->methodName();
    $app->component->methodName();.
    Component::methodName();

---
To bind classes to the IoC container:
 
    $app->bind('UsersController', function($app) {
        $controller = new UsersController(
            new Response,
            $app->make('request'),
            $app->make('validator'),
            $app->make('hash'),
            new User
        );
        return $controller;
    });
 
At this point, we can make the class, using
    $app->make('UsersController') ;


---
Migrations and Seeding
Migrations are like version control for your databases.
 
    php artisan migrate:make create_users_table 

creates the basic structure for a new 'users' table. Fill it in further, to get:
    public function up()
    {
        Schema::create('users', function($table) {
            $table->increments('id')->unsigned();   // auto-increments an unsigned id field
            $table->string('name',50);              // sets to length you entered
            $table->string('email');                // sets to varchar 200
            $table->string('password');
            $table->boolean('activated')->default(0);   // sets a default value
            $table->integer('age')->nullable();         // allows nulls
            $table->timestamps();                       // creates created_at and modified_at fields
        });
    }

Use seeds to add sample records:
Create a file within the app/database/seeds folder that has the same name as the table that it corresponds to; in our case, users.php. Add:
    <?php 
    return array(
        array(
            'username' => 'firstuser',
            'password' => Hash::make('first_password'),
            'created_at' => new DateTime,
            'updated_at' => new DateTime
        ),
        array(
            'username' => 'seconduser',
            'password' => Hash::make('second_password'),
            'created_at' => new DateTime,
            'updated_at' => new DateTime
        )
    );
 
 
Run the migrations and insert sample records:
    // Make sure the auto-loader knows about these new classes
    php composer.phar dump-autoload

To run the migration:
    php artisan migrate                     // run all migrations that have not been run
    php artisan migrate:refresh             // roll back and re-run all migrations
    php artisan migrate:refresh --seed      // refresh, then seed the database
    php artisan db:seed                     // seed the database

---
Artisan Class Generator
jeffrey way (nettuts) has created an add-in for artisan, which can automatically generate items for you.
    require "way/generators": "dev-master"           (composer.json)
    'Way\Generators\GeneratorsServiceProvider'       (add to providers array)

    php artisan generate:resource

--- 
Controllers:

    php artisan controller:make <Controller name>

creates lots of functions, including:

      index   GET  - collection, eg site/photos
      create  GET  - display form to add new record - site/photos/create
      store   POST - take input from new item, write new record
      edit    GET  - display form to edit record - site/photos/1/edit
      update  PUT  - submitted form, update existing record
      show    GET  - item, eg site/photos/1
      destroy DELETE sent - delete an object
 
    Route::resource('photos','PhotosController');
 
Laravel 4 is restful by default.
in index(), if you return Photo::all(), you'll get json output

These are equivalent ways to return data to a user:
    return Photo::all();  
or
    $photos = Photo::all();
    return View::make('photos.index', compact('photos'));
or
    return View::make('photos.index')->with(array('photos' => $photos));
 
In a view, to get a link to the photos.show method (parameter id), use:
  <a href="{{ route('photos.show', ['photos' => $photo->id]) }}"> 

photos/create -> POST photos -> photos/store
photos/edit/1 -> PUT photos/1 -> photos/1/update
GET photos/id/delete
DELETE photos/id


---
Models

By default, the table name will be plural, and the model name will be singular. This can be changed, though…
 
Table   Model   Controller
users   User    UsersController
 
To use something else, in the model,
 
    <?php
    class User extends Eloquent {
        public static $table = 'my_user_table';
    }

---
Routing:
Here are a few different ways to send variables to the default view:
 
via the routes.php file:
    $data = array(
        'greeting'   => 'hello',
        'something'  => 'world',
        'items'      => array('Item1', 'Item2', 'Item3', 'Item4'),
        'data_items' => array('First','Second')
    );

    Route::get('/', function() {
        return View::make('home.index', $data);
    };

or:

    Route::get('/', function() {
        return View::make('home.index')->with($data);        
    });

or:

    Route::get('/', function() {
        $view = View::make('home.index');
        $view->greeting = 'Hi';
        $view->something = 'Everyone';
        return $view;
    });
 
Via a controller:
 
(in routes.php):
    Route::controller('home');
 
(in controllers/home.php):
    public function action_index() {
        return View::make('home.index', $data);
    }



Differences Between Laravel 3 and 4

Run a server to show Laravel data (need php 5.4.x):
  L3: php -S localhost:8888 -t public     (go to localhost:8888 to get to the page)
  L4: php artisan serve
 
Route declarations:
  L3: Route::get('users/(:num)', function(id){ var_dump( $id ); });
  L4: Route::get('users/{id}', function(id){ var_dump( $id ); })
            ->where('id','\d+');        // regular expression, 1+ digits
 
Templates:
  L3: Route::get('/', 'Home@index');
 
      Home_Controller
        public $layout='master';
        public function action_index() {
            $this->layout->content = View::make('home.index');
            (or return View::make('home.index'), with @layout('master') in index.blade.php)
   
      master.blade.php:
        <div>@yield('content')
      index.blade.php:
        @layout('master')          // if layout not specified in controller
        @section('content')
          Home Page here
        @endsection
 
  L4: Route::get('/', 'HomeController@index');
 
      HomeController:
        protected $layout='master';
        public function index() {
            $this->layout->content = View::make('home.index')
            (or return View::make('home.index'), with @extends('master') in index.blade.php)
   
      master.blade.php:
        <div>@yield('content')
      index.blade.php:
        @extends('master')       // if layout not specified in controller
        @section('content')
          Home Page here
        @stop  (to declare the end of a section)
   
Forms:
  L3:   {{ Form::open('users') }}
            {{ Form::label('firstname', 'First Name') }}
            {{ Form::text('firstname') }}
        {{ Form::close() }}
 
  L4:   <currently unavailable>
 
  L3:  HTML::link
  L4:  HTML::to
  
Migrations:
  L3:
      php artisan migrate:install                         // install the migrations table
      php artisan migrate:make create_posts_table         // then update the table
      artisan migrate:rollback                            // roll back the previous migration
      artisan migrate:reset                               // roll back all migrations
  L4: (all of the L3 commands will work...)
      php artisan migrate:make create_posts_table --table=posts --create
        (does not need artisan migrate:install)
      artisan migrate:refresh                       // roll back everything, and re-run
      artisan migrate:refresh --seed                // do the above, and run all seeds

Seeding tables:
  L3: <does not have that functionality>
  L4: Prepare seed files as described above, then enter:
        artisan db:seed
      or:
        artisan migrate:refresh --seed
 

Laravel 4 includes Route Model Binding (inject model instances into route closures)
It automatically returns all collections from a method or closure as JSON

Routes (without route model binding): 
  L3:   Route::get('users', function() { return User::all(); }});
  L4:   Route::get('users/{id}', function($id) { return User::find($id); }})->where('id', '\d+');

Routes (with route model binding):
  L4:   Route::model('user', 'User');
  or:   Route::bind('user', function($id, $route) { return User::where('id', $id)->first(); }));
        Route::get('users/{user}', function (User $user) { return $user; }));
 
Linking to routes in a view: 
  L3:   HTML::link_to_route('routeName', 'Display')
  L4:   <a href="{{URL::route('routeName')}}>Display</a>
  or:   HTML::to(URL::route('routeName'), 'Display')

Redirection:
  L3:   Redirect::to_route('routeName')
  L4:   Redirect::route('routeName')

Redirection with errors and input:
  L3:   Redirect::with_errors()->with_input()
  L4:   Redirect::withErrors()->withInput()
 
Reporting errors in a view:
  L3:   @if($errors->has())
            <p>The following errors have occurred:</p>
     
            <ul id="form-errors">
                {{ $errors->first('username','<li>:message</li>')}}
                {{ $errors->first('password','<li>:message</li>')}}
            </ul>
        @endif
 
  L4:   The L3 way still works, or:
        @if($errors->has())                    // or @if(count($errors)>0)
            <ul id="form-errors">
                <li>{{ $errors->first('username') }}</li>
                <li>{{ $errors->first('password') }}</li>
           </ul>
        @endif
 
Laravel creates everything for REST. Refer to individual objects like this:
  <a href="{{ route('questions.show', ['questions'=>$question->id]) }}">
 
Updating data: 
  L3:   Questions::update($id, array(
            'question' => Input::get('question'),
            'solved' => Input::get('solved'),
        ));
 
  L4:   Questions::where('id','=',$id)->update(array(
            'question' => Input::get('question'),
            'solved' => Input::get('solved'),
        ));
 

Including stylesheets: 
  L3:   {{ HTML::style('css/main.css') }}
  L4:   <link href="{{route('home')}}/css/main.css" media="all" type="text/css" rel="stylesheet">


  
----------------------------------------------------------------------------
Moving forward:


When deleting objects, my idea was to just set a 'deleted' flag on the base object. It has problems, though, with unique fields, searching, etc. (we have to keep looking for that deleted flag in every query...). Instead, could we combine the data into a text field, and write it to an archive table?

